from __future__ import annotations

from uuid import uuid4
from typing import List

from pydantic import BaseModel, Field

from ..core.llm import LLMError, get_llm_client
from ..core.prompt import load_prompt
from ..observability.llm_obs import traceable_node
from ..observability.logging import get_logger
from .state import (
    ActionCategory,
    ActionItem,
    ActionPlan,
    ActionPriority,
    SellerState,
)

logger = get_logger("agents.planner")


class PlannerLLMAction(BaseModel):
    area: str = "general"
    title: str
    description: str
    priority: str = "medium"
    impact: str = "medium"
    product_id: str | None = None


class PlannerLLMActionPlan(BaseModel):
    overall_summary: str = ""
    actions: List[PlannerLLMAction] = Field(default_factory=list)


class PlannerLLMOutput(BaseModel):
    """
    Expected LLM JSON output for the planner.

    We intentionally reuse ActionItem/ActionPlan structure so that the
    LLM mirrors our domain model closely.
    """

    action_plan: PlannerLLMActionPlan = Field(
        ...,
        description="Structured action plan generated by the planner agent.",
    )


def _to_action_category(value: str) -> ActionCategory:
    normalized = (value or "").strip().lower()
    mapping = {
        "pricing": ActionCategory.PRICING,
        "listing": ActionCategory.LISTING,
        "seo": ActionCategory.SEO,
        "inventory": ActionCategory.INVENTORY,
        "compliance": ActionCategory.COMPLIANCE,
        "profitability": ActionCategory.PROFITABILITY,
    }
    return mapping.get(normalized, ActionCategory.OTHER)


def _to_action_priority(value: str) -> ActionPriority:
    normalized = (value or "").strip().lower()
    if normalized == "low":
        return ActionPriority.LOW
    if normalized == "high":
        return ActionPriority.HIGH
    if normalized == "critical":
        return ActionPriority.CRITICAL
    return ActionPriority.MEDIUM


def _normalize_action_plan(llm_plan: PlannerLLMActionPlan) -> ActionPlan:
    actions: List[ActionItem] = []
    for action in llm_plan.actions:
        actions.append(
            ActionItem(
                id=f"planner-{uuid4().hex[:8]}",
                product_id=action.product_id,
                title=action.title,
                description=action.description,
                category=_to_action_category(action.area),
                priority=_to_action_priority(action.priority),
                estimated_impact=action.impact,
            )
        )
    return ActionPlan(overall_summary=llm_plan.overall_summary, actions=actions)


def _build_planner_context(state: SellerState) -> str:
    """
    Build a text context summarizing the current SellerState for the planner.

    We keep this deterministic and relatively lightweight. The prompt
    template can decide how much of this to include verbatim vs using as hints.
    """
    lines: List[str] = []

    if state.query:
        lines.append("## User Query")
        lines.append(state.query.raw_query)
        lines.append("")
        if state.query.seller_name:
            lines.append(f"- Seller name: {state.query.seller_name}")
        if state.query.session_id:
            lines.append(f"- Session ID: {state.query.session_id}")
        if state.query.memory_facts:
            lines.append("## Memory Facts")
            for fact in state.query.memory_facts:
                lines.append(f"- {fact}")
            lines.append("")
        if state.query.recent_chat_turns:
            lines.append("## Recent Conversation")
            for turn in state.query.recent_chat_turns:
                lines.append(f"- {turn}")
            lines.append("")

    if state.seller_profile:
        lines.append("## Seller Profile")
        lines.append(f"- Total products: {state.seller_profile.total_products}")
        lines.append(f"- Active products: {state.seller_profile.active_products}")
        if state.seller_profile.marketplaces:
            lines.append(
                f"- Marketplaces: {', '.join(state.seller_profile.marketplaces)}"
            )
        if state.seller_profile.primary_categories:
            lines.append(
                f"- Primary categories: {', '.join(state.seller_profile.primary_categories)}"
            )
        lines.append(f"- Summary: {state.seller_profile.summary}")
        lines.append("")

    if state.sales_analyses:
        lines.append("## Sales Highlights (up to 5 products)")
        for a in state.sales_analyses[:5]:
            lines.append(
                f"- Product {a.product_id}: units={a.total_units_sold}, "
                f"revenue={a.total_gross_revenue:.2f}, returns={a.total_returns}, "
                f"CR={a.conversion_rate if a.conversion_rate is not None else 'n/a'}"
            )
        lines.append("")

    if state.competitor_analyses:
        lines.append("## Competitor Highlights (up to 5 products)")
        for c in state.competitor_analyses[:5]:
            lines.append(
                f"- Product {c.product_id}: competitors={c.num_competitors}, "
                f"seller_avg_price={c.seller_avg_price}, "
                f"avg_comp_price={c.avg_competitor_price}"
            )
        lines.append("")

    if state.inventory_analyses:
        lines.append("## Inventory & Risk (up to 5 products)")
        for inv in state.inventory_analyses[:5]:
            lines.append(
                f"- Product {inv.product_id}: stock={inv.current_stock}, "
                f"reorder_level={inv.reorder_level}, "
                f"risk={inv.risk_level.value}, "
                f"days_of_cover={inv.projected_days_of_cover}"
            )
        lines.append("")

    if state.compliance_analyses:
        lines.append("## Compliance Overview")
        for ca in state.compliance_analyses:
            label = f"Product {ca.product_id}" if ca.product_id else "Overall"
            lines.append(f"- {label}: {ca.summary}")
        lines.append("")

    if state.rag_context:
        lines.append("## RAG Context")
        lines.append(
            f"- Marketplace: {state.rag_context.marketplace or 'any'}; "
            f"chunks={len(state.rag_context.chunks)}"
        )
        lines.append("")

    return "\n".join(lines)


@traceable_node("planner_agent")
def _call_planner_llm(prompt: str) -> PlannerLLMOutput:
    """
    Internal LLM call wrapped with LangSmith tracing.
    """
    client = get_llm_client()
    return client.generate_structured(prompt, PlannerLLMOutput)


def update_action_plan(state: SellerState) -> SellerState:
    """
    Planner Agent.

    Responsibilities:
      - Take all existing analyses in state (sales, competitor, inventory, compliance)
      - Generate a prioritized, structured ActionPlan
      - Attach it to state.action_plan
    """
    planner_prompt_template = load_prompt("planner")  # e.g., prompts/planner_v1.md

    context_text = _build_planner_context(state)

    # We do not assume any specific .format() placeholders inside the prompt
    # to keep it robust. Instead, we append a clearly delimited context section.
    complete_prompt = (
        planner_prompt_template
        + "\n\n"
        + "-----\n\n"
        + "## Structured Context for Planner\n\n"
        + context_text
    )

    logger.info("Planner agent invoking LLM for action plan")

    try:
        llm_output = _call_planner_llm(complete_prompt)
    except LLMError as exc:
        # On failure, fall back to a placeholder action plan rather than
        # failing the entire graph run.
        logger.error(
            "Planner LLM call failed; falling back to placeholder action plan",
            extra={"error": str(exc)},
        )

        if state.action_plan is None:
            state.action_plan = ActionPlan(
                overall_summary=(
                    "Planner agent failed to generate an action plan. "
                    "Please try again later."
                ),
                actions=[],
            )
        return state

    state.action_plan = _normalize_action_plan(llm_output.action_plan)

    logger.info(
        "Planner agent updated action plan from LLM",
        extra={"num_actions": len(state.action_plan.actions)},
    )

    return state
